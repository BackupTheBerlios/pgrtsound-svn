// Class automatically generated by Dev-C++ New Class wizard

#include "xmlconfigfile.h" // class's header file

XMLConfigFile::XMLConfigFile() {
}

XMLConfigFile::~XMLConfigFile() {
	TRACE("XMLConfigFile::~XMLConfigFile()", "Destrukcja...");
	TRACE("XMLConfigFile::~XMLConfigFile()", "Destrukcja pomyslna");
}

void XMLConfigFile::OpenFile(const char * filename) {
	fileName = filename;

    if ( !document.LoadFile(fileName.c_str()) ) {
		throw RTSError("Nie mozna wczytac pliku " + (string)fileName +
			"! Error: " + document.ErrorDesc());
    }
    
}

/**
 * Wczytuje algorytm opisany w pliku
 * @param algo Wskaznik do konfigurowanego algorytmu
*/
void XMLConfigFile::LoadAlgorithm(Algorithm* algo) {
	TRACE("XMLConfigFile::LoadModules()", "Wczytywanie calego algorytmu...");
	LoadModules(algo);
	LoadParameters(algo);
	LoadConnections(algo);
	TRACE("XMLConfigFile::LoadModules()", "Algorytm wczytany");
}

/**
 * Wczytuje modu³y zadeklarowane w pliku
  * @param algo Wskaznik do konfigurowanego algorytmu
*/
void XMLConfigFile::LoadModules(Algorithm* algo) {

    TRACE("XMLConfigFile::LoadModules()", "Wczytywanie modulow...");

	TiXmlElement* moduleXMLElem;
	TiXmlNode* moduleXMLNode, * parent;
	string moduleName;
	int moduleId;

    // zmapowanie modulow specjlanych
	moduleName2IdMap.insert(make_pair("AudioPortIn", 0));
	moduleName2IdMap.insert(make_pair("AudioPortOut", 1));

    TiXmlHandle docHandle( &document );
	parent = docHandle.FirstChild( "algorithm" ).FirstChild( "modules" ).Child("module", 0).Node();

	// przez wszystkie inne moduly
	if(parent != NULL) {
		for( moduleXMLNode = parent; moduleXMLNode; moduleXMLNode = moduleXMLNode->NextSibling("module") ) {
			moduleXMLElem = moduleXMLNode->ToElement();
			moduleName = moduleXMLElem->Attribute("name");
			moduleId = algo->AddModule(moduleXMLElem->Attribute("type"));
			algo->GetModule(moduleId)->SetName(moduleName);
			moduleName2IdMap.insert(make_pair(moduleName, moduleId));
  		}
	}

	TRACE("XMLConfigFile::LoadModules()", "Moduly wczytane");
}

/**
 * Funckja wczytuj¹ca parametry modu³ów
 * @param algo Wskaznik do konfigurowanego algorytmu
*/
void XMLConfigFile::LoadParameters(Algorithm* algo) {
	TRACE("XMLConfigFile::LoadParameters()", "Wczytywanie parametrow...");

	string paramValue, paramType;
  	int paramId, moduleId;
	TiXmlElement* moduleElem, * paramElem;
	TiXmlNode* moduleNode, * parent, * paramTxt;

    TiXmlHandle docHandle( &document );
	parent = docHandle.FirstChild( "algorithm" ).FirstChild( "modules" ).Child("module", 0).Node();

	//cout << "PARENT: " << parent << endl;

	// wszystkie moduly
	for( moduleNode = parent; moduleNode; moduleNode = moduleNode->NextSibling("module") ) {
		moduleElem = moduleNode->ToElement();
		moduleId = (*moduleName2IdMap.find(moduleElem->Attribute("name"))).second;

		// wszystkie parametry kazdego modulu
		for( paramElem = moduleNode->FirstChildElement("parameter");
			paramElem;
			paramElem = paramElem->NextSiblingElement("parameter") )
		{
			if(paramElem != NULL) {
                paramTxt = paramElem->FirstChild();
                paramType = paramElem->Attribute("type");
				paramId = atoi(paramElem->Attribute("number"));

				if(paramTxt != NULL) {
					paramValue = paramTxt->Value();
				}
    			#ifndef NDEBUG
				cout << "    " << moduleElem->Attribute("name") << "." <<
					algo->GetModule(moduleId)->GetParameter(paramId)->GetName() << " = ";
				#endif

				if(paramType == "float") {
					float value;
					ParameterFloat* param =
						(ParameterFloat*)algo->GetModule(moduleId)->GetParameter(paramId);
					value = atof( paramValue.c_str() );
					param->SetValue(value);
					#ifndef NDEBUG
						cout << param->GetValue() << endl;
					#endif
				}

				if(paramType == "string") {
					ParameterString* param =
						(ParameterString*)algo->GetModule(moduleId)->GetParameter(paramId);
					param->SetText(paramValue);
					#ifndef NDEBUG
					    cout << param->GetText() << endl;
				    #endif
				}
			}
		}
	}
	
	TRACE("XMLConfigFile::LoadParameters()", "Parametry wczytane");
}

/**
 * Funckja wczytuj¹ca polaczenia miêdzy modu³ami
 * @param algo Wskaznik do konfigurowanego algorytmu
*/
void XMLConfigFile::LoadConnections(Algorithm* algo) {
    TRACE("XMLConfigFile::LoadConnections()", "Wczytywanie polaczen...");

	string module1Name, module2Name;
  	int module1Id = -1, module2Id = -1, inputId = -1, outputId = -1;
	TiXmlElement* connElem;
	TiXmlNode* connNode, * parent;

	TiXmlHandle docHandle( &document );
	parent = docHandle.FirstChild( "algorithm" ).FirstChild( "connections" ).Child("connection", 0).Node();

	for( connNode = parent; connNode; connNode = connNode->NextSibling("connection") ) {
		connElem = connNode->ToElement();

		module1Name = connElem->Attribute("name1");
		module1Id = ( *moduleName2IdMap.find(module1Name) ).second;
		
		module2Name = connElem->Attribute("name2");
		module2Id = ( *moduleName2IdMap.find(module2Name) ).second;
		
		inputId = atoi( connElem->Attribute("input") );
		outputId = atoi( connElem->Attribute("output") );

		algo->ConnectModules(module1Id, outputId, module2Id, inputId);
		
		#ifndef NDEBUG
		cout << "    " <<
		    module1Name << "(" << module1Id << ")." <<
			algo->GetModule(module1Id)->GetOutput(outputId)->GetName() <<
			"(" <<	outputId << ")" <<
			" -> " <<
   		    module2Name << "(" << module2Id << ")." <<
			algo->GetModule(module2Id)->GetInput(inputId)->GetName() <<
   		    "(" << inputId << ")" << endl;
		#endif
		
	}

    TRACE("XMLConfigFile::LoadConnections()", "Moduly polaczone");
}
